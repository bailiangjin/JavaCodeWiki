# 排序算法总结
[TOC]
## 常用排序算法  



### 冒泡排序

简介：

1、冒泡排序是一种用时间换空间的排序方法，n小时好  
2、最坏情况是把顺序的排列变成逆序，或者把逆序的数列变成顺序，最差时间复杂度O(N^2)只是表示其操作次数的数量级  
3、最好的情况是数据本来就有序，复杂度为O(n)

代码：

```
    /**
     * 冒泡排序
     *
     * @param array
     */
    public static void bubbleSort(int[] array) {

        int n = array.length;

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n - 1 - i; j++) {
                if (array[j] > array[j + 1]) {
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
    }
    
```  


###  插入排序
  
这个算法从数组的第二个元素开始循环，将选中的元素与之前的元素一一比较，如果选中的元素小于之前的元素，则将之前的元素后移，最后再将选中的元素放在合适的位置。在这个算法执行的过程中，总是保持着索引i之前的数组是升序排列的。
插入排序理解起来比较简单，因此LZ就不过多的解释它的实现原理了，尚未理解的猿友可以自行研究。

代码：

```
    /**
     * 插入排序
     *
     * @param array
     */
    public static void insertionSort(int[] array) {
        int n = array.length;
        for (int i = 1; i < n; i++) {
            int key = array[i];
            int j = i - 1;
            while (j > -1 && (array[j] > key)) {
                array[j + 1] = array[j];
                j--;
            }
            array[j + 1] = key;
        }
    }
    
```






## 排序算法对比



类别    |算法名     | 平均时间复杂度 |空间复杂度    |稳定性   |复杂性      
------- |----------|------------- |------------|--------|------
交换排序 |冒泡排序   | O(N2) |O(1)|稳定|简单
：：    |快速排序   | O(N*log2N) |O(log2n)~O(n)|不稳定|简单
插入排序 |直接插入   | O(N2) |O(1)|稳定|简单
：：    |希尔排序   |O(N1.3)|O(1)| 不稳定|复杂
选择排序 |直接选择排序| O(N2) |O(1)|不稳定|简单
：：    |堆排序     | O(N*log2N) |O(1)|不稳定|复杂
归并排序 |归并排序   |  O(N*log2N)|O(n)| 稳定| 复杂
基数排序 |基数排序   |  O(d(r+n))|O(d(r+n))| 稳定| 复杂


注：基数排序：r代表关键字基数，d代表长度，n代表关键字个数

思考：为什么快速排序的空间复杂度是lg(n)~n，这是因为快速排序是递归的，每个递归深度都会产生一些临时变量，所以它的空间复杂度跟递归深度有关。

