# 排序算法总结
[TOC]
## 常用排序算法  



### 冒泡排序

代码：

```
    /**
     * 冒泡排序
     *
     * @param array
     */
    public static void bubbleSort(int[] array) {

        int n = array.length;

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n - 1 - i; j++) {
                if (array[j] > array[j + 1]) {
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
    }
    
```  


###  插入排序
  
这个算法从数组的第二个元素开始循环，将选中的元素与之前的元素一一比较，如果选中的元素小于之前的元素，则将之前的元素后移，最后再将选中的元素放在合适的位置。在这个算法执行的过程中，总是保持着索引i之前的数组是升序排列的。
插入排序理解起来比较简单，因此LZ就不过多的解释它的实现原理了，尚未理解的猿友可以自行研究。

代码：

```
    /**
     * 插入排序
     *
     * @param array
     */
    public static void insertionSort(int[] array) {
        int n = array.length;
        for (int i = 1; i < n; i++) {
            int key = array[i];
            int j = i - 1;
            while (j > -1 && (array[j] > key)) {
                array[j + 1] = array[j];
                j--;
            }
            array[j + 1] = key;
        }
    }
    
```






## 排序算法对比



类别    |算法名     | 平均时间复杂度 |空间复杂度  |稳定性       
--------|----------| -------------|----------|---
交换排序|冒泡排序    | O(N2) |O(1)|稳定
：：|快速排序    | O(N*log2N) |O(log2n)~O(n)|不稳定
插入排序|直接插入 | O(N2) |O(1)|稳定
：：|希尔排序|O(N1.3)|O(1)| 不稳定
选择排序|直接选择排序    | O(N2) |O(1)|不稳定
：：|堆排序    | O(N*log2N) |O(1)|不稳定
归并排序|归并排序    |  O(N*log2N)|O(n)| 稳定
基数排序|基数排序    |  O(d(r+n))|O(d(r+n))| 稳定


注：基数排序：r代表关键字基数，d代表长度，n代表关键字个数

思考：为什么快速排序的空间复杂度是lg(n)~n，这是因为快速排序是递归的，每个递归深度都会产生一些临时变量，所以它的空间复杂度跟递归深度有关。

